
# ===================================================================================
#                              GIT COMMANDS CHEAT SHEET
# ===================================================================================

# TABLE OF CONTENTS
# -----------------
# 1. Git Basics & Setup
# 2. Remote Interaction
# 3. Branch Management
# 4. Merging
# 5. Rebasing
# 6. Conflict Resolution
# 7. Logs and History
# 8. Undo & Reset
# 9. Staging & Committing
# 10. Tagging
# 11. Feature Branch Workflow
# 12. Merge Conflict Resolution Cheat Sheet
# 13. Git Stash
# 14. Git Cherry-Pick
# 15. Debugging & Investigation
# 16. Appendix: Vim Commands for Git

# ===================================================================================

#  Git Basics & Setup -------------------------------------------------------------------

git init                                            # Initialize a new git repository locally [Mandatory]
git clone <repo-url>                                # Clone an existing remote repository
git config --global user.name "Name"                # Set your global git {username}
git config --global user.email "email@example.com"  # Set your global {email}
git config --global core.editor "code --wait"       # Set VS Code as default editor

#  Remote Interaction -------------------------------------------------------------------

git remote -v                            # List all remotes and their URLs (mainly github repo)
git remote add origin <repo-url>         # Add a remote repo called 'origin'

# Note: fetch brings data to local repo (not working directory), pull fetches and merges to working directory
git fetch                                # Fetch all remote branches without merging
git pull                                 # Fetch and merge into current branch

git fetch --prune                        # Fetch and clean deleted remote branches locally
git pull origin <branch>                 # Fetch and merge remote branch into current branch
git push origin <branch>                 # Push your local branch to remote
git push -u origin <branch>              # Push and set upstream tracking branch
git push origin --delete <branch>        # Delete a remote branch


#  Branch Management-------------------------------------------------------------------

git branch                               # List local branches
git branch -r                            # List remote branches
git branch -a                            # List all branches (local + remote)
git branch <new-branch>                  # Create a new branch (locally)
git checkout <branch>                    # Switch to an existing branch
git checkout -b <new-branch>             # Create and switch to a new branch (older style)
git switch <branch>                      # Switch branch (modern)
git switch -c <new-branch>               # Create and switch (modern)
git branch -d <branch>                   # Delete a local branch (only if merged)
git branch -D <branch>                   # Force delete a local branch (even if unmerged)

#  Merging-------------------------------------------------------------------

git checkout main                        # Switch to main branch
git merge <feature-branch>               # Merge feature into current branch
git merge --no-commit --no-ff <branch>   # Merge but stop before committing (to review changes)
git merge --abort                        # Abort merge if conflicts

#  Rebasing -------------------------------------------------------------------

# Rebase replays your commits on top of another branch (cleaner history than merge)
git rebase <branch>                      # Rebase current branch onto <branch>
git rebase main                          # Rebase current branch onto main
git rebase -i HEAD~3                     # Interactive rebase last 3 commits (squash, reorder, edit)
git rebase --continue                    # Continue after resolving rebase conflicts
git rebase --abort                       # Abort rebase and return to original state

# When to use rebase vs merge:
# - Use rebase for feature branches before merging (cleaner history)
# - Use merge for shared branches or when you want to preserve branch history
# - Never rebase commits that have been pushed to a shared branch

#  Conflict Resolution-------------------------------------------------------------------

# After resolving conflicts:
git add <file>
git commit

#  Logs and History -------------------------------------------------------------------

git log                                  # Full commit history
git log --oneline --graph --all          # Visual branch graph
git status                               # Show current changes
git diff                                 # Show unstaged changes
git diff --staged                        # Show staged changes (before commit)
git show <commit-hash>                   # Show a specific commit

#  Undo & Reset -------------------------------------------------------------------

git reset --hard HEAD                    # Reset to last commit (dangerous)
git checkout -- <file>                   # Discard changes in working directory for a file
git restore <file>                       # Discard changes (modern alternative to checkout --)
git reset HEAD <file>                    # Unstage a staged file (keep changes in working dir)
git reset --soft HEAD~1                  # Undo last commit but keep changes staged
git reset --mixed HEAD~1                 # Undo last commit and unstage changes
git reset --hard HEAD~1                  # Undo last commit and discard all changes (dangerous!)
git revert <commit-hash>                 # Create a new commit that undoes a previous commit (safe for pushed commits)
git reflog                               # Show history of HEAD changes (useful for recovering lost commits)


#  Staging & Committing -------------------------------------------------------------------

git add .                                # Stage all files
git add <file>                           # Stage one file
git commit -m "Your message"             # Commit staged changes
git commit --amend                       # Modify the last commit (message or add files)
git commit --amend -m "New message"      # Change last commit message
git commit --amend --no-edit             # Add staged files to last commit without changing message

#  Tagging -------------------------------------------------------------------

git tag                                  # List all tags
git tag <tag-name>                       # Create a lightweight tag
git tag -a v1.0.0 -m "Version 1.0.0"     # Create an annotated tag with message
git tag -a v1.0.0 <commit-hash>          # Tag a specific commit
git show <tag-name>                      # Show tag details
git push origin <tag-name>               # Push a specific tag to remote
git push origin --tags                   # Push all tags to remote
git tag -d <tag-name>                    # Delete a local tag
git push origin --delete <tag-name>      # Delete a remote tag

# Feature Branch Workflow-------------------------------------------------------------------

git checkout main
git pull origin main
git checkout -b <feature-branch>
# Make changes
git add .
git commit -m "Do some stuff"
git push origin <feature-branch>
# Merge later:
git checkout main
git pull origin main
git merge <feature-branch>
git push origin main
# Optionally delete:
git branch -d <feature-branch>
git push origin --delete <feature-branch>

Git Merge Conflict Resolution Cheat Sheet
============================================

Detecting Conflicts
---------------------------------------------------
To merge or pull and possibly create conflicts:
    git pull origin <branch>
    # or
    git merge <branch>

If there are conflicts, Git will show:
    CONFLICT (content): Merge conflict in <file>
    Automatic merge failed; fix conflicts and then commit the result.

Fixing Conflicts
---------------------------------------------------------
Note : 1. Don't work on main
       2. One patch = one feature
       3. rebase early , rebase often
       4. Pull before you push

Open each conflicted file and resolve manually. Look for markers like:
    <<<<<<< HEAD
    // your local changes
    =======
    // incoming changes from other branch
    >>>>>>> branch-name

Edit to keep the correct content and remove these markers.

Mark as Resolved
----------------------------------------------------
After fixing each file:
    git add <file>

Commit the Merge
----------------------------------------------------
Finish the merge with:
    git commit
    # This will open the merge editor; save and close it.

Optional Tools
----------------------------------------------------
Keep YOUR version:
    git checkout --ours <file>
    git add <file>

Keep THEIR version:
    git checkout --theirs <file>
    git add <file>

Abort the Merge
----------------------------------------------------
If you want to cancel the merge:
    git merge --abort

Example Flow
----------------------------------------------------
    git pull origin main
    # Fix conflicts in each file manually
    git add 1327A.cpp
    git add 1373B.cpp
    ...
    git commit
    git push origin main

Done!

# ---------------------------------------------------------
GIT STASH AND CHERRY-PICK:

git stash:
1. git stash temporarily saves uncommitted changes.
2. It is used when you want to switch branches without committing.
3. After stashing, the working directory becomes clean.

What git stash saves:
    ->Modified tracked files
    ->Staged files

What git stash does NOT save:
    ->Untracked files unless -u is used
    ->Ignored files unless -a is used

Basic stash command:
    "git stash"
    ->Saves changes and resets the working directory.

Stash with message:
    --->git stash push -m "message"<---
    ->Saves changes with a description.

Include untracked files:
    git stash -u
    git stash --include-untracked

Include ignored files also:

1. git stash -a

Viewing stashes

1. git stash list

Example output

1. stash@{0}: WIP on main
2. stash@{1}: On dev

Applying stash without deleting

1. git stash apply
2. git stash apply stash@{1}
3. Applies stash but keeps it in the stash list.

Applying stash and deleting

1. git stash pop
2. Applies stash and removes it from the stash list.

Difference between apply and pop

1. apply applies changes and stash remains.
2. pop applies changes and stash is removed.

Deleting stashes

1. git stash drop stash@{0}
   Deletes a specific stash.

2. git stash clear
   Deletes all stashes permanently.

When to use git stash

1. Switching branches quickly
2. Saving half done work
3. Temporary experiments
4. Keeping a clean working tree

GIT CHERRY-PICK

1. Cherry-pick applies specific commit or commits from another branch.
2. It creates new commits with new commit hashes.
3. It does not merge the entire branch.

Basic usage

1. git cherry-pick <commit-hash>
   Cherry-picks a single commit.

2. git cherry-pick c1 c2 c3
   Cherry-picks multiple commits.

3. git cherry-pick A..B
   Cherry-picks commits after A up to B.

Cherry-pick with conflict

1. git status
   Shows conflicting files.

2. Resolve conflicts manually.

3. git cherry-pick --continue {Continues after conflicts are resolved.}

4. git cherry-pick --abort (Aborts the cherry-pick operation.)

Cherry-pick without commit:

1. git cherry-pick -n <commit>
2. git cherry-pick --no-commit <commit>
3. Applies changes without creating a commit immediately.

When to use cherry-pick:

1. Apply hotfix from another branch
2. Backport bug fixes
3. Select specific commits only
4. Avoid full merge

Note: If you have uncommitted changes and need to switch branches to test something,
      use git stash to save your work, switch branches, test, then switch back and
      use git stash pop to restore your changes. Useful for testing patches.

# ---------------------------------------------------------
GIT DEBUGGING & INVESTIGATION:

git blame <file>                         # Show who changed each line and when
git blame -L 10,20 <file>                # Blame specific lines (10-20)

git bisect start                         # Start binary search for bug-introducing commit
git bisect bad                           # Mark current commit as bad (has bug)
git bisect good <commit>                 # Mark a known good commit
git bisect reset                         # End bisect session

# Bisect workflow:
# 1. git bisect start
# 2. git bisect bad (current commit has the bug)
# 3. git bisect good v1.0 (v1.0 was working fine)
# 4. Git checks out middle commit - test it and mark as good/bad
# 5. Repeat until Git finds the first bad commit
# 6. git bisect reset (when done)

git reflog                               # Show all HEAD movements (useful for recovery)
git reflog show <branch>                 # Show reflog for specific branch

# Recovery example:
# If you accidentally reset or deleted commits:
# 1. git reflog (find the commit hash before the mistake)
# 2. git reset --hard <commit-hash> (restore to that point)

# ===================================================================================
# APPENDIX: Vim Commands for Git
# ===================================================================================

When Git prompts for a commit message (e.g., during a merge), it often opens the default editor: Vim.

What does `:wq` mean?
----------------------------------------------
In Vim:
  :w  - Writes (saves) the file.
  :q  - Quits the editor.

So, `:wq` saves your commit message and exits Vim.

Steps to Use `:wq` After a Merge Conflict
----------------------------------------------
1. Type your commit message (or leave the default one).
2. Press `Esc` (to ensure you're not in insert mode).
3. Type `:wq` and press `Enter`.

This completes the merge and exits the editor.

Other useful Vim commands:
----------------------------------------------
  :q!  - Quit without saving (abort the commit)
  i    - Enter insert mode (to type)
  Esc  - Exit insert mode
  dd   - Delete current line
  u    - Undo last change

Alternative Editors for Git
-----------------------------------------------
To avoid Vim and use a simpler editor like VS Code or Nano:

Set VS Code as Git editor:
    git config --global core.editor "code --wait"

Set Nano as Git editor:
    git config --global core.editor "nano"

This will make Git open your preferred editor for commit messages.
